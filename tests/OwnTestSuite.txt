======================================================================
==== Intrinsic method "len" (using indexed-access)
s = "Hello"
print s["len"]

a = [1,2,3,4]
print a["len"]

m = {"a": "A", "b": "B"}
print m["len"]
----------------------------------------------------------------------
5
4
2
======================================================================
==== Intrinsic method "indexOf" (using indexed-access)
s = "Hello"
print s["indexOf"]("o")

a = [1,2,3,4]
print a["indexOf"](3)

m = {"a": "A", "b": "B"}
print m["indexOf"]("B")
----------------------------------------------------------------------
4
2
b
======================================================================
==== Intrinsic method "indexOf"
s = "Hello"
print s.indexOf("o")

a = [1,2,3,4]
print a.indexOf(3)

m = {"a": "A", "b": "B"}
print m.indexOf("B")
----------------------------------------------------------------------
4
2
b
======================================================================
==== Intrinsic method "len"
s = "Hello"
print s.len

a = [1,2,3,4]
print a.len

m = {"a": "A", "b": "B"}
print m.len
----------------------------------------------------------------------
5
4
2
======================================================================
==== Self-function with "self" in non-first positions

myList = {}
myList.elements = [1,2,3,4,5,6,7,8]

countMultiplesOfNr = function(value, initial, self)
	count = initial
	for x in self.elements
		if x % value == 0 then count = count + 1
	end for
	return count
end function

// As standalone function
print countMultiplesOfNr(2, 40, myList)

// As self-method (the "self" parameter
// gets populated with the object)
myList.countMultiplesOfNr = @countMultiplesOfNr
print myList.countMultiplesOfNr(2, 40)
----------------------------------------------------------------------
44
44
======================================================================
==== Self-functions
==== These are functions which can be called as stand-alone or added to 
==== an object and called as methods. These functions have "self" as the 
==== first parameter. When called stand-alone the relevant object is passed
==== manually. When called as a method, miniScript fills the first parameter
==== for you and you should not pass it.

myList = {}
myList.elements = [1,2,3,4,5,6,7,8]

countMultiplesOfNr = function(self, value)
	count = 0
	for x in self.elements
		if x % value == 0 then count = count + 1
	end for
	return count
end function

// As standalone function
print countMultiplesOfNr(myList, 2)

// As self-method (the "self" parameter
// gets populated with the object)
myList.countMultiplesOfNr = @countMultiplesOfNr
print myList.countMultiplesOfNr(2)
----------------------------------------------------------------------
4
4
======================================================================
==== Parameter passing order
==== This is how standard miniScript behaves

// Note that repeated argument names are allowed
f = function(a,b,a=123)
	print a
end function

// First "a" gets assigned 33
// But because the second "a" is not passed it gets assigned 123

f 33
// Same even if no parameters passed
f
----------------------------------------------------------------------
123
123
======================================================================
==== More advanced function reference
f1 = function(a,b)
	return a + b
end function

f2 = @f1

m = {}
m.f2 = @f1

f3 = function(ignored)
	return m
end function

print @m.f2
print @f3(3)["f2"]

// Substitute function with value
// Referencing function now return value

m.f2 = "value"

print @m.f2
print @f3(3)["f2"]
----------------------------------------------------------------------
FUNCTION(a, b)
FUNCTION(a, b)
value
value
======================================================================
==== Simple function reference
f1 = function(a,b)
	return a + b
end function

f2 = @f1

print f2(2,3)
print @f2
print @f1 == @f2
----------------------------------------------------------------------
5
FUNCTION(a, b)
1
======================================================================
==== Parameter-list after space in statement
==== ... should produce a parse-error
range (0,3)
----------------------------------------------------------------------
Compiler Error: got Comma where RParen is required [line 1]
======================================================================
==== Space before parameters
// This is a statement-function call, consisting of a call to print 
// and a silent (no output) multiplication of the resulting value
// ("null", returned by print) with 3

print("hello") * 3

// Because this is a statement, the first space after the identifier 
// marks the beginning of parameter-expressions. Thus it's interpreted
// as a grouped expression consisting only of one string, and then
// multipliying by 3.

m = {}
m.pr = function(txt)
	print txt
end function

m[ "pr" ] ("hello") * 3

// Because `range (0,3)` is within a statement no further statements
// can occur. Therefor identifier followed by an opening parens must
// be a function call.

print range (0,3)

// This looks like parameter list, but it's really a grouped value.
// Adding a ",3" results in a parsing error.

x = {}
x.f = function(t,a)
	print "Hi " * t
end function

x["f"] (2)

----------------------------------------------------------------------
hello
hellohellohello
[0, 1, 2, 3]
Hi Hi 
======================================================================
==== Arithmetic with null
// null on the left
print null * 3
print null + 2
print null - 4
print null / 4
print null ^ 3
print null % 2
// null on the right
print 2 + null
print 3 * null
print 5 - null
print 7 / null
print 3 ^ null
print 3 % null
----------------------------------------------------------------------
null
null
null
null
null
null
2
0
5
Infinity
1
NaN
======================================================================
==== Calls on indexed access
a = {}
a.sayTimes = function(word, times)
  s = (word + " ")
	print s * times
end function
a["sayTimes"]("hello",3)
----------------------------------------------------------------------
hello hello hello 
======================================================================
==== Self calls
m2 = {}
m2.fff = function(a,b)
	self.hello
	self["there"](3)
	return a * b
end function
m2.hello = function
	print "Hello"
end function
m2.there = function(x)
	print "there " * x
end function

m1 = {}
m1.f = function
	return m2
end function

print m1.f.fff(2,3)
----------------------------------------------------------------------
Hello
there there there 
6
======================================================================
==== Simple dot-call
m = {}
m.addNr = function(a=1,b=1)
	return a+b
end function
print m.addNr(6)
print m.addNr(2,2)
print m.addNr
----------------------------------------------------------------------
7
4
2
======================================================================
==== Simple dot-assignment
m = {"x": 12, "y": 24}
m.x = 123
m.y = 456
print m
----------------------------------------------------------------------
{"x": 123, "y": 456}
======================================================================
==== Simple dot-access (without self-reference)
m = {"x": 12, "y": 24}
print m.x
print m.y
----------------------------------------------------------------------
12
24
======================================================================
==== Calling with fewer arguments
==== Arguments not passed are filled with null or default values.
==== Note also that default values don't need to be contiguous.
f = function(a,b="B",c)
	print a
	print b
	print c
	print ""
end function
f
f "A"
f "X","Y"
----------------------------------------------------------------------
null
B
null

A
B
null

X
Y
null

======================================================================
==== Printing function object
x = [1,2,3]
x[0] = function; end function
x[1] = function(a); end function
x[2] = function(a, b=123); end function
print x
----------------------------------------------------------------------
[FUNCTION(), FUNCTION(a), FUNCTION(a, b=123)]
======================================================================
==== Instant evaluation of functions
==== Functions should be immediately called when gotten out of a 
==== collection
aList = [1,2,3]
aMap = {}
aList[0] = function
  print "Function 1 executed"
end function
aMap["key"] = function
  print "Function 2 executed"
end function
aList[0]
aMap["key"]
----------------------------------------------------------------------
Function 1 executed
Function 2 executed
======================================================================
==== Map instantiation with `new`
==== Also test property resolution up the inheritance chain
==== Setting property on sub-object should not modify upper object
m1 = {"one": 1, "two": 2}
m2 = new m1
m2["two"] = "TWO"
print m2["one"]
print m1["two"]
print m2["two"]
----------------------------------------------------------------------
1
2
TWO
======================================================================
==== Unary minus
a = 2
b = 3
print -(a*b)
----------------------------------------------------------------------
-6
======================================================================
==== Unary "not" (boolean)
a = 3
b = 4
if not a > b then
	print "a was not greater than b"
else
	print "a was greater than b"
end if
----------------------------------------------------------------------
a was not greater than b
======================================================================
==== Map indexed setting
m = {"key": "value", 2: "two", "3": "three"}
m[2] = "TWO"
m["3"] = "3"
print m[2]
print m["3"]
----------------------------------------------------------------------
TWO
3
======================================================================
==== Map indexed access
m = {"key": "value", 2: "two", "3": "three", null: "123"}
print m[2]
print m["3"]
print m[null]
----------------------------------------------------------------------
two
three
123
======================================================================
==== Map expressions
a = [1,2,3]
f = function(p)
	return p * 2
end function
print {"key": "value", 2: "two", "3": false}
print {"key": a, 2: f("blah"), "3": a[2]}
----------------------------------------------------------------------
{"key": "value", 2: "two", "3": 0}
{"key": [1, 2, 3], 2: "blahblah", "3": 3}
======================================================================
==== List expressions
a = [1,2,3]
b = "Hello"
c = function
	return "BLAH"
end function
d = [a,b,c]
print d
----------------------------------------------------------------------
[[1, 2, 3], "Hello", "BLAH"]
======================================================================
==== Not equals
print 42 != [42]
----------------------------------------------------------------------
1
======================================================================
==== Comparison-chain expression (e.g. a <= b <= c)
print 0 <= 3 > 1
print 7 > 4 > 1
x = 3
print 1 < x <= 1
----------------------------------------------------------------------
1
1
0
======================================================================
==== Short-circuit boolean operations
idem = function(x,operation)
	print "idem("+x+","+operation+")"
	return x
end function
// Short circuit OR ... should only call first one
idem(true,"OR") or idem(false,"OR")
// Short circuit AND ... should only call first one
idem(false,"AND") and idem(true,"AND") 
----------------------------------------------------------------------
idem(1,OR)
idem(0,AND)
======================================================================
==== Implicit: rnd
print rnd >= 0
print rnd < 1
----------------------------------------------------------------------
1
1
======================================================================
==== Implicit: str
a = str(123)
b = "123"
print a == b
----------------------------------------------------------------------
1
======================================================================
==== String Subtraction
print "banana.txt" - ".txt"
print "banana" - "na" * 2
// Don't subtract anything ... it only subtracts suffixes (at the end)
print "banana" - "ban"
// Test subtracting more than first string
print "123" - "1234567"
----------------------------------------------------------------------
banana
ba
banana
123
======================================================================
==== String Comparison
print "ABC" < "EFG"
print "ABC" >= "EFG"
print "a" < "efg"
print "a" > "A"
print "A" > "a"
print "z" < "z"
print "Z" < "z"
print "Foo" == "FOO"
print "Foo" == "Foo"
----------------------------------------------------------------------
1
0
1
1
0
0
1
0
1
======================================================================
==== String replication
print "MINI" * 1
print "MINI" * 2
print "MINI" * 2.5
print "MINI" * 2.75
print "MINI" * 0
print "MINI" * -1.5
----------------------------------------------------------------------
MINI
MINIMINI
MINIMINIMI
MINIMINIMIN


======================================================================
==== String concatenation (between two strings)
print "Hello " + "World!"
----------------------------------------------------------------------
Hello World!
======================================================================
==== String concatenation (between String and other types)
print "Hello " + 123
print 120 + 3 + "-45" + 6
print "numbers: " + [1,2,3]
print [4,5,6] + " are my numbers"
----------------------------------------------------------------------
Hello 123
123-456
numbers: [1, 2, 3]
[4, 5, 6] are my numbers
======================================================================
==== Simple string indexed access
s = "HELLO"
print s[3]
print s[-4]
----------------------------------------------------------------------
L
E
======================================================================
==== String slicing
s = "HELLO"
print s[2:3]
print s[2:4]
print s[2:]
print s[:2]
print s[-4:-2]
----------------------------------------------------------------------
L
LL
LLO
HE
EL
======================================================================
==== List equality
list1 = [0, 10, 20, 30, 40]
list2 = [100, -200, 300]
print "Equality 1: " + (list1 == list2)
listA = list2
print "Equality A: " + (listA == list2)
listB = [100, -200] + [300]
print "Equality B: " + (listB == list2)
----------------------------------------------------------------------
Equality 1: 0
Equality A: 1
Equality B: 1
======================================================================
==== List slicing
list1 = [0, 10, 20, 30, 40]
print list1[:3]
print list1[3:]
print list1[1:-1]
print [10,20,30,40,50][2:4]
----------------------------------------------------------------------
[0, 10, 20]
[30, 40]
[10, 20, 30]
[30, 40]
======================================================================
==== List concatenation
==== Lists can be concatenated one to the other. The result is a new
==== list with the elements of both.
list1 = [0, 10, 20, 30, 40]
list2 = [100, -200, 300]
print list1 + list2
----------------------------------------------------------------------
[0, 10, 20, 30, 40, 100, -200, 300]
======================================================================
==== List replication
==== The "*" operator (followed by a number) produces a new list by 
==== replicating the elements in the given list. Floating point and 
==== negative numbers are also allowed. For floating points the length
==== of the list and the factor are multiplied and then "floored", then
==== normal replication is applied. For 0 or negative numbers the result
==== is an empty list.
print [1,2,3] * 2
print [1,2,3] * 2.5
print [1,2,3] * 0.4
print [1,2,3] * -2.5
print [1,2,3] * 0
----------------------------------------------------------------------
[1, 2, 3, 1, 2, 3]
[1, 2, 3, 1, 2, 3, 1]
[1]
[]
[]
======================================================================
==== Spaces before parameters
==== The parser should parse "func (1,2,3)" as "func(1,2,3)"
foo = function(x)
    return x
end function
foo (3)
// range (0, 3) produces an error
range(0, 3)
print foo (3)
print range (0, 3)
----------------------------------------------------------------------
3
[0, 1, 2, 3]
======================================================================
==== Simple list assignment
a = [1,2,3]
a[1] = 4
a[-1] = 5
print a
----------------------------------------------------------------------
[1, 4, 5]
======================================================================
==== Simple list access
a = [1,2,3]
print a[1]
print a[-1]
----------------------------------------------------------------------
2
3
======================================================================
==== Recursive Fibonacci
fib = function(n)
  if n <= 1 then
    return n
  else
    return fib(n-1) + fib(n-2)
  end if
end function
print "Result: " + fib(15)
----------------------------------------------------------------------
Result: 610
======================================================================
==== Parent-scope variable resolution
==== This case shows how a variable in a parent scope should be resolved
f1 = function
    // Define variable in local scope
    x = 123
    // A child scope is created, having a parent one
    f2 = function
        // Should access "x" from parent scope
        print x
    end function
    // Call the function
    f2
end function
// Call the outer-most function
f1
----------------------------------------------------------------------
123
======================================================================
==== for-loop with break and continue
for i in range(1,9)
	if i == 3 then continue
	if i == 6 then break
	print i
end for
print "done"
----------------------------------------------------------------------
1
2
4
5
done
======================================================================
==== printing simple array
==== Should not be printed as a JS object, but formatted
print [1,2,3]
print ["1","2","3"]
----------------------------------------------------------------------
[1, 2, 3]
["1", "2", "3"]
======================================================================
==== modulus (remainder) "%" operator
print 6 % 3
print -6 % 3
print -1 % 3
print 1 % 3
print 1 % -3
print -1 % -3
----------------------------------------------------------------------
0
0
-1
1
1
-1
======================================================================
==== while with break and continue
i = 0
while i < 10
    i = i + 1
    if i == 3 then continue
    if i == 6 then break
    print i
end while
print "done"
----------------------------------------------------------------------
1
2
4
5
done
======================================================================
==== Runtime shadowing of for-variables in local context
==== Here we demonstrate how a for-loop variable is accessible in a 
==== sub-function, but as soon as an assignment takes place there a 
==== *local* version of that variable appears, and shadows the one in
==== the upper context. IMPORTANT: this behavior is only known at 
==== RUNTIME, it cannot be deduced analytically. Here we have two 
==== if-branches (if/else) and sometimes the upper variable is overriden
==== and sometimes not.
f1 = function
	x = 3
	f2 = function
		// Starting here, x is guaranteed to be defined
		for x in range(1,5)
			f = function
				if x % 2 == 0 then
					// ASSIGNMENT always creates a new local
					// variable if one does not exist in the 
					// local scope - this is known only at
					// runtime. The "x" in the print refers
					// to the newly created "x" (local)
					x = 10
					print "f's local x: " + x
				else
					// The "x" here is resolved to the one
					// in the outer scope, at RUNTIME
					print "f's for-Loop x: " + x
				end if
				// The "x" here is resolved to either local
				// or outer scope at RUNTIME, depending on
				// which if branch was executed.
				print "f's resolved x: " + x		
			end function
			print ""
			f
			print "for-loop x: " + x
		end for
	end function
	return f2
end function

f1
----------------------------------------------------------------------

f's for-Loop x: 1
f's resolved x: 1
for-loop x: 1

f's local x: 10
f's resolved x: 10
for-loop x: 2

f's for-Loop x: 3
f's resolved x: 3
for-loop x: 3

f's local x: 10
f's resolved x: 10
for-loop x: 4

f's for-Loop x: 5
f's resolved x: 5
for-loop x: 5
----------------------------------------------------------------------