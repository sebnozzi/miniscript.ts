======================================================================
==== Simple dot-access (without self-reference)
m = {"x": 12, "y": 24}
m["foo"] = function(a,b)
	return a + b
end function
print m.x
print m.y
print m.foo(3,2)
----------------------------------------------------------------------
12
24
5
======================================================================
==== Calling with fewer arguments
==== Arguments not passed are filled with null or default values.
==== Note also that default values don't need to be contiguous.
f = function(a,b="B",c)
	print a
	print b
	print c
	print ""
end function
f
f "A"
f "X","Y"
----------------------------------------------------------------------
null
B
null

A
B
null

X
Y
null

======================================================================
==== Printing function object
x = [1,2,3]
x[0] = function; end function
x[1] = function(a); end function
x[2] = function(a, b=123); end function
print x
----------------------------------------------------------------------
[FUNCTION(), FUNCTION(a), FUNCTION(a, b=123)]
======================================================================
==== Instant evaluation of functions
==== Functions should be immediately called when gotten out of a 
==== collection
aList = [1,2,3]
aMap = {}
aList[0] = function
  print "Function 1 executed"
end function
aMap["key"] = function
  print "Function 2 executed"
end function
aList[0]
aMap["key"]
----------------------------------------------------------------------
Function 1 executed
Function 2 executed
======================================================================
==== Map instantiation with `new`
==== Also test property resolution up the inheritance chain
==== Setting property on sub-object should not modify upper object
m1 = {"one": 1, "two": 2}
m2 = new m1
m2["two"] = "TWO"
print m2["one"]
print m1["two"]
print m2["two"]
----------------------------------------------------------------------
1
2
TWO
======================================================================
==== Unary minus
a = 2
b = 3
print -(a*b)
----------------------------------------------------------------------
-6
======================================================================
==== Unary "not" (boolean)
a = 3
b = 4
if not a > b then
	print "a was not greater than b"
else
	print "a was greater than b"
end if
----------------------------------------------------------------------
a was not greater than b
======================================================================
==== Map indexed setting
m = {"key": "value", 2: "two", "3": "three"}
m[2] = "TWO"
m["3"] = "3"
print m[2]
print m["3"]
----------------------------------------------------------------------
TWO
3
======================================================================
==== Map indexed access
m = {"key": "value", 2: "two", "3": "three", null: "123"}
print m[2]
print m["3"]
print m[null]
----------------------------------------------------------------------
two
three
123
======================================================================
==== Map expressions
a = [1,2,3]
f = function(p)
	return p * 2
end function
print {"key": "value", 2: "two", "3": false}
print {"key": a, 2: f("blah"), "3": a[2]}
----------------------------------------------------------------------
{"key": "value", 2: "two", "3": 0}
{"key": [1, 2, 3], 2: "blahblah", "3": 3}
======================================================================
==== List expressions
a = [1,2,3]
b = "Hello"
c = function
	return "BLAH"
end function
d = [a,b,c]
print d
----------------------------------------------------------------------
[[1, 2, 3], "Hello", "BLAH"]
======================================================================
==== Not equals
print 42 != [42]
----------------------------------------------------------------------
1
======================================================================
==== Comparison-chain expression (e.g. a <= b <= c)
print 0 <= 3 > 1
print 7 > 4 > 1
x = 3
print 1 < x <= 1
----------------------------------------------------------------------
1
1
0
======================================================================
==== Short-circuit boolean operations
idem = function(x,operation)
	print "idem("+x+","+operation+")"
	return x
end function
// Short circuit OR ... should only call first one
idem(true,"OR") or idem(false,"OR")
// Short circuit AND ... should only call first one
idem(false,"AND") and idem(true,"AND") 
----------------------------------------------------------------------
idem(1,OR)
idem(0,AND)
======================================================================
==== Implicit: rnd
print rnd >= 0
print rnd < 1
----------------------------------------------------------------------
1
1
======================================================================
==== Implicit: str
a = str(123)
b = "123"
print a == b
----------------------------------------------------------------------
1
======================================================================
==== String Subtraction
print "banana.txt" - ".txt"
print "banana" - "na" * 2
// Don't subtract anything ... it only subtracts suffixes (at the end)
print "banana" - "ban"
// Test subtracting more than first string
print "123" - "1234567"
----------------------------------------------------------------------
banana
ba
banana
123
======================================================================
==== String Comparison
print "ABC" < "EFG"
print "ABC" >= "EFG"
print "a" < "efg"
print "a" > "A"
print "A" > "a"
print "z" < "z"
print "Z" < "z"
print "Foo" == "FOO"
print "Foo" == "Foo"
----------------------------------------------------------------------
1
0
1
1
0
0
1
0
1
======================================================================
==== String replication
print "MINI" * 1
print "MINI" * 2
print "MINI" * 2.5
print "MINI" * 2.75
print "MINI" * 0
print "MINI" * -1.5
----------------------------------------------------------------------
MINI
MINIMINI
MINIMINIMI
MINIMINIMIN


======================================================================
==== String concatenation (between two strings)
print "Hello " + "World!"
----------------------------------------------------------------------
Hello World!
======================================================================
==== String concatenation (between String and other types)
print "Hello " + 123
print 120 + 3 + "-45" + 6
print "numbers: " + [1,2,3]
print [4,5,6] + " are my numbers"
----------------------------------------------------------------------
Hello 123
123-456
numbers: [1, 2, 3]
[4, 5, 6] are my numbers
======================================================================
==== Simple string indexed access
s = "HELLO"
print s[3]
print s[-4]
----------------------------------------------------------------------
L
E
======================================================================
==== String slicing
s = "HELLO"
print s[2:3]
print s[2:4]
print s[2:]
print s[:2]
print s[-4:-2]
----------------------------------------------------------------------
L
LL
LLO
HE
EL
======================================================================
==== List equality
list1 = [0, 10, 20, 30, 40]
list2 = [100, -200, 300]
print "Equality 1: " + (list1 == list2)
listA = list2
print "Equality A: " + (listA == list2)
listB = [100, -200] + [300]
print "Equality B: " + (listB == list2)
----------------------------------------------------------------------
Equality 1: 0
Equality A: 1
Equality B: 1
======================================================================
==== List slicing
list1 = [0, 10, 20, 30, 40]
print list1[:3]
print list1[3:]
print list1[1:-1]
print [10,20,30,40,50][2:4]
----------------------------------------------------------------------
[0, 10, 20]
[30, 40]
[10, 20, 30]
[30, 40]
======================================================================
==== List concatenation
==== Lists can be concatenated one to the other. The result is a new
==== list with the elements of both.
list1 = [0, 10, 20, 30, 40]
list2 = [100, -200, 300]
print list1 + list2
----------------------------------------------------------------------
[0, 10, 20, 30, 40, 100, -200, 300]
======================================================================
==== List replication
==== The "*" operator (followed by a number) produces a new list by 
==== replicating the elements in the given list. Floating point and 
==== negative numbers are also allowed. For floating points the length
==== of the list and the factor are multiplied and then "floored", then
==== normal replication is applied. For 0 or negative numbers the result
==== is an empty list.
print [1,2,3] * 2
print [1,2,3] * 2.5
print [1,2,3] * 0.4
print [1,2,3] * -2.5
print [1,2,3] * 0
----------------------------------------------------------------------
[1, 2, 3, 1, 2, 3]
[1, 2, 3, 1, 2, 3, 1]
[1]
[]
[]
======================================================================
==== Spaces before parameters
==== The parser should parse "func (1,2,3)" as "func(1,2,3)"
foo = function(x)
    return x
end function
print foo (3)
print range (0, 3)
----------------------------------------------------------------------
3
[0, 1, 2, 3]
======================================================================
==== Simple list assignment
a = [1,2,3]
a[1] = 4
a[-1] = 5
print a
----------------------------------------------------------------------
[1, 4, 5]
======================================================================
==== Simple list access
a = [1,2,3]
print a[1]
print a[-1]
----------------------------------------------------------------------
2
3
======================================================================
==== Recursive Fibonacci
fib = function(n)
  if n <= 1 then
    return n
  else
    return fib(n-1) + fib(n-2)
  end if
end function
print "Result: " + fib(15)
----------------------------------------------------------------------
Result: 610
======================================================================
==== Parent-scope variable resolution
==== This case shows how a variable in a parent scope should be resolved
f1 = function
    // Define variable in local scope
    x = 123
    // A child scope is created, having a parent one
    f2 = function
        // Should access "x" from parent scope
        print x
    end function
    // Call the function
    f2
end function
// Call the outer-most function
f1
----------------------------------------------------------------------
123
======================================================================
==== for-loop with break and continue
for i in range(1,9)
	if i == 3 then continue
	if i == 6 then break
	print i
end for
print "done"
----------------------------------------------------------------------
1
2
4
5
done
======================================================================
==== printing simple array
==== Should not be printed as a JS object, but formatted
print [1,2,3]
print ["1","2","3"]
----------------------------------------------------------------------
[1, 2, 3]
["1", "2", "3"]
======================================================================
==== modulus (remainder) "%" operator
print 6 % 3
print -6 % 3
print -1 % 3
print 1 % 3
print 1 % -3
print -1 % -3
----------------------------------------------------------------------
0
0
-1
1
1
-1
======================================================================
==== while with break and continue
i = 0
while i < 10
    i = i + 1
    if i == 3 then continue
    if i == 6 then break
    print i
end while
print "done"
----------------------------------------------------------------------
1
2
4
5
done
======================================================================
==== Runtime shadowing of for-variables in local context
==== Here we demonstrate how a for-loop variable is accessible in a 
==== sub-function, but as soon as an assignment takes place there a 
==== *local* version of that variable appears, and shadows the one in
==== the upper context. IMPORTANT: this behavior is only known at 
==== RUNTIME, it cannot be deduced analytically. Here we have two 
==== if-branches (if/else) and sometimes the upper variable is overriden
==== and sometimes not.
f1 = function
	x = 3
	f2 = function
		// Starting here, x is guaranteed to be defined
		for x in range(1,5)
			f = function
				if x % 2 == 0 then
					// ASSIGNMENT always creates a new local
					// variable if one does not exist in the 
					// local scope - this is known only at
					// runtime. The "x" in the print refers
					// to the newly created "x" (local)
					x = 10
					print "f's local x: " + x
				else
					// The "x" here is resolved to the one
					// in the outer scope, at RUNTIME
					print "f's for-Loop x: " + x
				end if
				// The "x" here is resolved to either local
				// or outer scope at RUNTIME, depending on
				// which if branch was executed.
				print "f's resolved x: " + x		
			end function
			print ""
			f
			print "for-loop x: " + x
		end for
	end function
	return f2
end function

f1
----------------------------------------------------------------------

f's for-Loop x: 1
f's resolved x: 1
for-loop x: 1

f's local x: 10
f's resolved x: 10
for-loop x: 2

f's for-Loop x: 3
f's resolved x: 3
for-loop x: 3

f's local x: 10
f's resolved x: 10
for-loop x: 4

f's for-Loop x: 5
f's resolved x: 5
for-loop x: 5
----------------------------------------------------------------------